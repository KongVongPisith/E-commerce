"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.FirebaseFunctions = void 0;
const functions_1 = require("firebase/functions");
const crypter_1 = require("../crypter");
const DatabaseType_1 = require("../DatabaseType");
const Expect_1 = require("./Expect");
const UtcDate_1 = require("../UtcDate");
class FirebaseFunctions {
    functions;
    cryptionKeys;
    callSecretKey;
    functionName;
    constructor(functions, cryptionKeys, callSecretKey, functionName) {
        this.functions = functions;
        this.cryptionKeys = cryptionKeys;
        this.callSecretKey = callSecretKey;
        this.functionName = functionName;
    }
    function(key) {
        return new FirebaseFunctions(this.functions, this.cryptionKeys, this.callSecretKey, this.functionName === undefined ? key : `${this.functionName}-${key}`);
    }
    async call(parameters) {
        const databaseType = new DatabaseType_1.DatabaseType('testing');
        const crypter = new crypter_1.Crypter(this.cryptionKeys);
        const expiresAtUtcDate = UtcDate_1.UtcDate.now.advanced({ minute: 1 });
        const functionName = this.functionName !== undefined ? `debug-${this.functionName}` : '';
        const callableFunction = (0, functions_1.httpsCallable)(this.functions, functionName);
        const httpsCallableResult = await callableFunction({
            verbose: 'coloredVerbose',
            databaseType: databaseType.value,
            callSecret: {
                expiresAt: expiresAtUtcDate.encoded,
                hashedData: crypter_1.Crypter.sha512(expiresAtUtcDate.encoded, this.callSecretKey)
            },
            parameters: crypter.encodeEncrypt(parameters)
        });
        const result = await crypter.decryptDecode(httpsCallableResult.data.result);
        return (0, Expect_1.expectResult)(result);
    }
}
exports.FirebaseFunctions = FirebaseFunctions;
